%% @author std-string

%% Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
%% Triangle : P(3,n) = n*(n+1)/2, P(3, n) = 1, 3, 6, 10, 15, ...
%% Square : P(4,n) = n^2, P(4, n) = 1, 4, 9, 16, 25, ...
%% Pentagonal : P(5,n) = n*(3n−1)/2, P(5,n) = 1, 5, 12, 22, 35, ...
%% Hexagonal : P(6,n) = n*(2n−1), P(6,n) = 1, 6, 15, 28, 45, ...
%% Heptagonal : P(7,n) = n*(5n−3)/2, P(7,n) = 1, 7, 18, 34, 55, ...
%% Octagonal : P(8,n) = n*(3n−2), P(8,n) = 1, 8, 21, 40, 65, ...
%% The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
%%
%% The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
%% Each polygonal type: triangle (P(3,127) = 8128), square (P(4,91) = 8281), and pentagonal (P(5,44) = 2882), is represented by a different number in the set.
%% This is the only set of 4-digit numbers with this property.
%% Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal,
%% is represented by a different number in the set.

-module(problem_061).
-export([get_check_data/0, prepare_data/2, solve/1]).

-behaviour(numerical_task_behaviour).

%% all numbers in 1000...9999
-define(TRIANGLE_INF, 45).
-define(TRIANGLE_SUP, 140).
-define(SQUARE_INF, 32).
-define(SQUARE_SUP, 99).
-define(PENTAGONAL_INF, 26).
-define(PENTAGONAL_SUP, 81).
-define(HEXAGONAL_INF, 23).
-define(HEXAGONAL_SUP, 70).
-define(HEPTAGONAL_INF, 21).
-define(HEPTAGONAL_SUP, 63).
-define(OCTAGONAL_INF, 19).
-define(OCTAGONAL_SUP, 58).

%% we skip 00.. 09
-define(STORAGE_SIZE, 89).
-define(STORAGE_DELTA, 10).

-type storage_type() :: array:array([pos_integer()]).
-type result_type() :: {N0 :: pos_integer(), N1 :: pos_integer(), N2 :: pos_integer(), N3 :: pos_integer(), N4 :: pos_integer(), N5 :: pos_integer()}.

%% ====================================================================
%% API functions
%% ====================================================================

get_check_data() ->
    [{none, 28684}].

prepare_data(_ModuleSourceDir, Input) -> Input.

solve(none) ->
    TriangleNumbers = lists:map(fun(N) -> N * (N + 1) div 2 end, lists:seq(?TRIANGLE_INF, ?TRIANGLE_SUP)),
    SquareNumbers = lists:map(fun(N) -> N * N end, lists:seq(?SQUARE_INF, ?SQUARE_SUP)),
    PentagonalNumbers = lists:map(fun(N) -> N * (3 * N - 1) div 2 end, lists:seq(?PENTAGONAL_INF, ?PENTAGONAL_SUP)),
    HexagonalNumbers = lists:map(fun(N) -> N * (2 * N - 1) end, lists:seq(?HEXAGONAL_INF, ?HEXAGONAL_SUP)),
    HeptagonalNumbers = lists:map(fun(N) -> N * (5 * N - 3) div 2 end, lists:seq(?HEPTAGONAL_INF, ?HEPTAGONAL_SUP)),
    OctagonalNumbers = lists:map(fun(N) -> N * (3 * N - 2) end, lists:seq(?OCTAGONAL_INF, ?OCTAGONAL_SUP)),
    TriangleStorage = create_storage(TriangleNumbers),
    SquareStorage = create_storage(SquareNumbers),
    PentagonalStorage = create_storage(PentagonalNumbers),
    HexagonalStorage = create_storage(HexagonalNumbers),
    HeptagonalStorage = create_storage(HeptagonalNumbers),
    Storages = [HeptagonalStorage, HexagonalStorage, PentagonalStorage, SquareStorage, TriangleStorage],
    {N0, N1, N2, N3, N4, N5} = process_number(OctagonalNumbers, Storages),
    N0 + N1 + N2 + N3 + N4 + N5.

%% ====================================================================
%% Internal functions
%% ====================================================================

-spec create_storage(Numbers :: [pos_integer()]) -> storage_type().
create_storage(Numbers) ->
    InitStorage = array:new([{size, ?STORAGE_SIZE}, {fixed, true}, {default, []}]),
    FoldlFun = fun(Number, Storage) ->
        FirstPart = Number div 100,
        SecondPart = Number rem 100,
        if
            SecondPart < 10 -> Storage;
            SecondPart >= 10 ->
                Index = FirstPart - ?STORAGE_DELTA,
                array:set(Index, [Number] ++ array:get(Index, Storage), Storage)
        end
    end,
    lists:foldl(FoldlFun, InitStorage, Numbers).

-spec process_number(Numbers :: [pos_integer()], Storages :: [storage_type()]) -> result_type() | no_return().
process_number([], _Storages) -> error(logic_error);
process_number([Number | Rest], Storages) ->
    case process_number(Number, Storages, 1) of
        {true, Value} -> Value;
        false -> process_number(Rest, Storages)
    end.

-spec process_number(N0 :: pos_integer(), Storages :: [storage_type()], Index :: 1..6) -> {'true', Value :: result_type()} | 'fasle'.
process_number(_N0, _Storages, 6) -> false;
process_number(N0, Storages, Index) ->
    {MainStorage, StoragesRest} = split(Storages, Index),
    N0SecondPart = N0 rem 100,
    N1List = array:get(N0SecondPart - ?STORAGE_DELTA, MainStorage),
    case find(fun(N1) -> process_number(N0, N1, StoragesRest, 1) end, N1List, [N0]) of
        {true, Value} -> {true, Value};
        false -> process_number(N0, Storages, Index + 1)
    end.

-spec process_number(N0 :: pos_integer(), N1 :: pos_integer(), Storages :: [storage_type()], Index :: 1..5) -> {'true', Value :: result_type()} | 'fasle'.
process_number(_N0, _N1, _Storages, 5) -> false;
process_number(N0, N1, Storages, Index) ->
    {MainStorage, StoragesRest} = split(Storages, Index),
    N1SecondPart = N1 rem 100,
    N2List = array:get(N1SecondPart - ?STORAGE_DELTA, MainStorage),
    case find(fun(N2) -> process_number(N0, N1, N2, StoragesRest, 1) end, N2List, [N0, N1]) of
        {true, Value} -> {true, Value};
        false -> process_number(N0, N1, Storages, Index + 1)
    end.

-spec process_number(N0 :: pos_integer(),
                     N1 :: pos_integer(),
                     N2 :: pos_integer(),
                     Storages :: [storage_type()],
                     Index :: 1..4) ->
    {'true', Value :: result_type()} | 'fasle'.
process_number(_N0, _N1, _N2, _Storages, 4) -> false;
process_number(N0, N1, N2, Storages, Index) ->
    {MainStorage, StoragesRest} = split(Storages, Index),
    N2SecondPart = N2 rem 100,
    N3List = array:get(N2SecondPart - ?STORAGE_DELTA, MainStorage),
    case find(fun(N3) -> process_number(N0, N1, N2, N3, StoragesRest, 1) end, N3List, [N0, N1, N2]) of
        {true, Value} -> {true, Value};
        false -> process_number(N0, N1, N2, Storages, Index + 1)
    end.

-spec process_number(N0 :: pos_integer(),
                     N1 :: pos_integer(),
                     N2 :: pos_integer(),
                     N3 :: pos_integer(),
                     Storages :: [storage_type()],
                     Index :: 1..3) ->
    {'true', Value :: result_type()} | 'fasle'.
process_number(_N0, _N1, _N2, _N3, _Storages, 3) -> false;
process_number(N0, N1, N2, N3, Storages, Index) ->
    {MainStorage, StoragesRest} = split(Storages, Index),
    N3SecondPart = N3 rem 100,
    N4List = array:get(N3SecondPart - ?STORAGE_DELTA, MainStorage),
    case find(fun(N4) -> process_number(N0, N1, N2, N3, N4, StoragesRest, 1) end, N4List, [N0, N1, N2, N3]) of
        {true, Value} -> {true, Value};
        false -> process_number(N0, N1, N2, N3, Storages, Index + 1)
    end.

-spec process_number(N0 :: pos_integer(),
                     N1 :: pos_integer(),
                     N2 :: pos_integer(),
                     N3 :: pos_integer(),
                     N4 :: pos_integer(),
                     Storages :: [storage_type()],
                     Index :: 1) ->
    {'true', Value :: result_type()} | 'fasle'.
process_number(N0, N1, N2, N3, N4, [MainStorage], 1) ->
    N4SecondPart = N4 rem 100,
    N0FirstPart = N0 div 100,
    N5 = N4SecondPart * 100 + N0FirstPart,
    N5List =  array:get(N4SecondPart - ?STORAGE_DELTA, MainStorage),
    case (N4 /= N5) andalso lists:member(N5, N5List) of
        true -> {true, {N0, N1, N2, N3, N4, N5}};
        false -> false
    end.

-spec split(Storages :: [storage_type()], Index :: pos_integer()) -> {Storage :: storage_type(), StoragesRest :: [storage_type()]}.
%% for Storage1 ... Storage2
split([Storage1, Storage2], 1) -> {Storage1, [Storage2]};
split([Storage1, Storage2], 2) -> {Storage2, [Storage1]};
split([_Storage1, _Storage2], 3) -> false;
%% for Storage1 ... Storage3
split([Storage1, Storage2, Storage3], 1) -> {Storage1, [Storage2, Storage3]};
split([Storage1, Storage2, Storage3], 2) -> {Storage2, [Storage1, Storage3]};
split([Storage1, Storage2, Storage3], 3) -> {Storage3, [Storage1, Storage2]};
split([_Storage1, _Storage2, _Storage3], 4) -> false;
%% for Storage1 ... Storage4
split([Storage1, Storage2, Storage3, Storage4], 1) -> {Storage1, [Storage2, Storage3, Storage4]};
split([Storage1, Storage2, Storage3, Storage4], 2) -> {Storage2, [Storage1, Storage3, Storage4]};
split([Storage1, Storage2, Storage3, Storage4], 3) -> {Storage3, [Storage1, Storage2, Storage4]};
split([Storage1, Storage2, Storage3, Storage4], 4) -> {Storage4, [Storage1, Storage2, Storage3]};
split([_Storage1, _Storage2, _Storage3, _Storage4], 5) -> false;
%% for Storage1 ... Storage5
split([Storage1, Storage2, Storage3, Storage4, Storage5], 1) -> {Storage1, [Storage2, Storage3, Storage4, Storage5]};
split([Storage1, Storage2, Storage3, Storage4, Storage5], 2) -> {Storage2, [Storage1, Storage3, Storage4, Storage5]};
split([Storage1, Storage2, Storage3, Storage4, Storage5], 3) -> {Storage3, [Storage1, Storage2, Storage4, Storage5]};
split([Storage1, Storage2, Storage3, Storage4, Storage5], 4) -> {Storage4, [Storage1, Storage2, Storage3, Storage5]};
split([Storage1, Storage2, Storage3, Storage4, Storage5], 5) -> {Storage5, [Storage1, Storage2, Storage3, Storage4]};
split([_Storage1, _Storage2, _Storage3, _Storage4, _Storage5], 6) -> false.


-spec find(Predicate :: fun((Number :: pos_integer()) -> boolean()), Numbers :: [pos_integer()], ExcludeList :: [pos_integer()]) ->
    {'true', Value :: term()} | 'false'.
find(_Predicate, [], _ExcludeList) -> false;
find(Predicate, [Number | Rest], ExcludeList) ->
    case lists:member(Number, ExcludeList) of
        false ->
            case Predicate(Number) of
                {true, Value} -> {true, Value};
                false -> find(Predicate, Rest, ExcludeList)
            end;
        true -> find(Predicate, Rest, ExcludeList)
    end.